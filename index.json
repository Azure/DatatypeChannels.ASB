[{"uri":"https://Azure.github.io/DatatypeChannels.ASB/index.html","title":"Data channeling API for Azure Service Bus\n","content":"(*** hide ***)\n#I \u0022../tests/DatatypeChannels.ASB.Tests/bin/Release/net5.0/publish\u0022\n#r \u0022Azure.Identity.dll\u0022\n#r \u0022Azure.Core.dll\u0022\n#r \u0022DatatypeChannels.ASB.dll\u0022\n#r \u0022Ply.dll\u0022\n#r \u0022Azure.Messaging.ServiceBus.dll\u0022\n\nopen System\nopen FSharp.Control.Tasks.Builders\nopen Azure.Messaging.ServiceBus.Administration\n\n(**\nData channeling API for Azure Service Bus\n======================\nDatatypeChannels.ASB implements [Datatype Channel pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DatatypeChannel.html) on top of official Azure Service Bus clients.\n\nA channel is an abstraction on top of Service Bus entities and it\u0027s implemented using topics, subscriptions and queues. \nThe core idea is that while there are many channels, all carrying messages, every channel is dedicated to a single type of message. \n\nIt works under assumptions that:\n\n- the bus toplogy is shared among heterogenous players, it\u0027s not a private implementation detail  \n- we can capture the message type via the topic \u002B subscription rules \n- the consumer is long-lived and handles only one type of message\n- the consumer decides when to pull the next message of a subscription or a queue\n- the publishers can be long- or short- lived\n- we have multiple serialization formats and may want to add new ones easily, this may introduce a new channel\n- we never want to loose a message, a message channel gets but is unable to read should be deadlettered\n- we control the receiving side of the bus topology and have \u0027Manage\u0027 permissions to create subscriptions and queues as necessary\n\n\nInstalling\n======================\n\n\u003Cdiv class=\u0022row\u0022\u003E\n  \u003Cdiv class=\u0022span1\u0022\u003E\u003C/div\u003E\n  \u003Cdiv class=\u0022span6\u0022\u003E\n    \u003Cdiv class=\u0022well\u0022 id=\u0022nuget\u0022\u003E\n      The DatatypeChannels.ASB library can be \u003Ca href=\u0022https://nuget.org/packages/DatatypeChannels.ASB\u0022\u003Einstalled from NuGet\u003C/a\u003E:\n      \u003Cpre\u003Edotnet add YOUR_PROJECT package DatatypeChannels.ASB\u003C/pre\u003E\n    \u003C/div\u003E\n  \u003C/div\u003E\n  \u003Cdiv class=\u0022span1\u0022\u003E\u003C/div\u003E\n\u003C/div\u003E\n\nExample\n-------\n\nThis example demonstrates the complete roundtrip over the channel using DatatypeChannels.ASB API:\n\n*)\nopen DatatypeChannels.ASB\n// create the entry point - DatatypeChannels\nlet channels = Channels.fromFqdn \u0022mynamespace.servicebus.windows.net\u0022\n                                 (Azure.Identity.DefaultAzureCredential false)\n                                 (Log ignore) // no logging\n\n// define the \u0022source\u0022 - subscription and routing rules, together called \u0022binding\u0022\nlet src = Subscription { Subscription = CreateSubscriptionOptions(\u0022mytopic\u0022, \u0022mysub\u0022, MaxDeliveryCount = 1), Rule = None }\n\n// create a consumer, specifying the convertion function from bus primitives\nlet consumer = channels.GetConsumer PlainText.ofReceived src // see the tutorial for details\n\n// create a publisher, specifying the target topic and the conversion function to bus primitives\nlet publisher = channels.GetPublisher PlainText.toSend (Topic \u0022mytopic\u0022)  // see the tutorial for details\nThreading.Thread.Sleep 5_000 // majic number - this is how long it takes the topic to start routing messages to new subscriptions\ntask {\n    do! publisher |\u003E Publisher.publish \u0022test-payload\u0022\n    let! received = TimeSpan.FromSeconds 3. |\u003E consumer.Get\n    printfn \u0022Received: %A\u0022 received\n    do! consumer.Ack received.Value.Id\n}\n\n(**\nNote that the API is task-based and the bindings are defined using \u0060Azure.Messaging.ServiceBus.Administration\u0060 types.\nConstructing a consumer establishes the connection and sets up or updates the subscription to the rule specified.\nOther types of consumer sources are \u0060DeadLetter\u0060, \u0060Queue\u0060 and \u0060Temporary\u0060.\n\n\nSamples \u0026 documentation\n-----------------------\n\n\n * [Tutorial](tutorial.html) goes into more details.\n\n \nContributing and copyright\n--------------------------\nThe project is hosted on [GitHub][gh] where you can [report issues][issues], fork \nthe project and submit pull requests. \n\nThe library is available under MIT license, which allows modification and \nredistribution for both commercial and non-commercial purposes. For more information see the \n[License file][license] in the GitHub repository. \n\n  [content]: https://github.com/Azure/DatatypeChannels.ASB/tree/master/docs/content\n  [gh]: https://github.com/Azure/DatatypeChannels.ASB\n  [issues]: https://github.com/Azure/DatatypeChannels.ASB/issues\n  [readme]: https://github.com/Azure/DatatypeChannels.ASB/blob/master/README.md\n  [license]: https://github.com/Azure/DatatypeChannels.ASB/blob/master/LICENSE.md\n\n\nCopyright 2021 Microsoft\n*)"},{"uri":"https://Azure.github.io/DatatypeChannels.ASB/tutorial.html","title":"Namespaces\n","content":"(*** hide ***)\n#I \u0022../tests/DatatypeChannels.ASB.Tests/bin/Release/net5.0/publish\u0022\n#r \u0022Azure.Core.dll\u0022\n#r \u0022Azure.Identity.dll\u0022\n#r \u0022DatatypeChannels.ASB.dll\u0022\n#r \u0022Ply.dll\u0022\n#r \u0022Azure.Messaging.ServiceBus.dll\u0022\n\nopen System\n(**\nNamespaces\n========================\n\nDatatypeChannels.ASB is organized into 3 APIs:\n\n- \u0060Channels\u0060 API - connects to Azure Service Bus and provides constructors for publishers and consumers \n- \u0060ToSend\u0060/\u0060OfReceived\u0060 types for packing and unpacking messages in and out of Azure Service Bus primitives\n- \u0060Publisher\u0060 and \u0060Consumer\u0060 types - the primary means of interaction\n\n\nChannels API\n========================\n\u0060Channels\u0060 is the entry point into the API, it can be constructed with a connection string or FQDN of the namespace, for example:\n*)\n\nopen DatatypeChannels.ASB\n\nuse channels = Channels.fromFqdn \u0022mynamespace.servicebus.windows.net\u0022\n                                 (Azure.Identity.DefaultAzureCredential false)\n                                 (Log ignore) // no logging\n\n(**\nFor other construction parameters please see \u0060Channels.mkNew\u0060.\nInternally two connections might be established - one for consumer bindings management and one for data activities.\nThe connections are established just in time for the first use and are cached for the lifetime of \u0060Channels\u0060 factory.\n\n\nConverting messages between application and bus representations\n========================\n\u0060Publisher\u0060 and \u0060Consumer\u0060 implement the opposite ends of a [Datatype Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DatatypeChannel.html), meaning that the type of message is determinated staticaly and for entire lifetime of the channel.\nImplement \u0060OfRecieved\u0060 and \u0060ToSend\u0060 functions to convert from/to service bus primitives. \n\nHere\u0027s an example of a plain text converters:\n\n*)\n\n\nmodule PlainText =\n    open Azure.Messaging.ServiceBus\n    let ofReceived  =\n        fun (sbm: ServiceBusReceivedMessage) -\u003E sbm.Body.ToString()\n        |\u003E OfReceived\n\n    let toSend =\n        fun (msg:string) -\u003E ServiceBusMessage(Body = BinaryData msg)\n        |\u003E ToSend\n\n\n\n(**\nAny exception during convertion from the bus primitives will result in message being Nacked and sent to the Dead Letter queue (if configured).\n\nPublisher\n========================\nPublisher is just a function that takes a message and returns when completed and \nthere are two ways to obtain it:\n\n- For long-living use:\n*)\n\nlet publisher = channels.GetPublisher PlainText.toSend (Topic \u0022topic\u0022) // long-living publisher\n(**\n- Or for immediate use and disposal of the publisher:\n\n*)\n\u0022test message\u0022 |-\u003E channels.UsingPublisher PlainText.toSend (Topic \u0022topic\u0022) // one-off publishing, using the infix operator\n\n\n(** Consumer\n========================\nConsumer implicitly manages the susbcription every time it\u0027s created, updating forwarding and rules as needed. \nA persistent queue can be setup using one or more subscriptions, each one will forward to the queue automatically. \n\u003E Note: a known issue prevents idle detection on subscriptions that have auto-forwarding defined.\n\n\u0060Temporary\u0060 queue can be useful for short-lived consumers and is setup with auto-acknowedgments and a guid for a name, it will be deleted once consumer is disposed of.\nImplementing guaranteed processing a \u0060Persistent\u0060 queue or a \u0060Subscription\u0060 with explicit Ack/Nack of the messages is recommended.\n\n*)\nopen Azure.Messaging.ServiceBus.Administration\n\n// define the a Subscription binding with no filters\nlet src = Subscription { Subscription = CreateSubscriptionOptions(\u0022mytopic\u0022, \u0022mysub\u0022, MaxDeliveryCount = 1), Rule = None }\n\n// create a consumer, specifying the convertion function from bus primitives\nlet consumer = channels.GetConsumer PlainText.ofReceived src\n\n// another example of a source - deadletter queue of the subscription defined above\n// this entity must exist, DatatypeChannels.ASB does not manage deadletter sources\nlet dlq = DeadLetter \u0022mytopic/Subscriptions/mysub\u0022 \nlet dlqConsumer = channels.GetConsumer PlainText.ofReceived dlq\n\n// define the a Persistent queue binding\nlet consumer = Persistent (CreateQueueOptions(\u0022myqueue\u0022, LockDuration = TimeSpan.FromMinutes 6.),\n                           [{ Subscription = CreateSubscriptionOptions(\u0022mytopic\u0022, \u0022mysub\u0022, MaxDeliveryCount = 1), Rule = None }])\n\n// define a Temporary queue binding, the messages will be auto-ack\u0027ed\nlet tmp = Temporary [{ Subscription = CreateSubscriptionOptions(\u0022mytopic\u0022, \u0022mysub\u0022, MaxDeliveryCount = 1), Rule = None }]\n\n(**\nOnce created, we can start polling them, specifying the timeout:\n\n*)\nopen FSharp.Control.Tasks.Builders\n\ntask {\n    let! received = TimeSpan.FromSeconds 3. |\u003E consumer.Get\n    // for this example - negative acknowledge the message so that it\u0027s routed to the deadletters\n    do! consumer.Nack received.Value.Id\n    let! received = TimeSpan.FromSeconds 3. |\u003E dlqConsumer.Get // now we can process it from the deadletters\n}\n\n(**\nNote that:\n\n- when using prefetch: w/ or not you called \u0060Get\u0060 the prefetch itself counts as a delivery attempt \n- if expected message processing, specified as \u0060LockDuration\u0060, exceeds the maximum lock time, DatatypeChannels.ASB will override the duration with the valida maximum and setup background lock renewal task.\n\n*)"}]